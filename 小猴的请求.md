#来自微信的验证（GET）
根据自身的token生成一个hash值返回给它即可

#来自用户的请求（POST）
来自用户的请求主要有两类（msgType）：

 - event
 - text
 
##event（事件模式）
通过点击下方的小按钮使用小猴，主要分为：

 - subscribe：新用户订阅
 - CLICK：下方工具条的点击，分为几种
     - 课表：
         - 更新课表
         - 明天课表
         - 今天课表
         - 下节课
     - 小工具：
         - 更新绑定信息
         - 教务信息
         - 空闲教室
         - 图书馆借书信息
         - 跑操次数
     - 更多...
        - 配对
        - 退出
        - 关于





##text（文本模式）
通过打字（文本）使用小猴的功能。

目标计划分为三种状态，如下：

 - 普通：可以通过文字如”下节课“等使用小猴按钮的操作。
 - 互聊：为用户分配一个同样处于这样状态的用户，供他们之间聊天（匿名）。
     - 申请配对中（1）
     - 已配对（11）
 
###设计思路

使用 **memcached** 在服务器内存中缓存着用户的**状态信息**，每次根据状态的不同而对用户的请求做不同的处理。

**默认**的用户状态为普通，即使用户不进行状态选择的事件触发。用户切换状态需要手动点击按钮进行切换。

####设定的用户操作
 - 用户原本处于未配对模式
 - 点击某个按钮，弹出一系列关于互聊的选择，如下：
     - 配对：
        - 0:进入配对状态,等待系统配对
        - 1:显示正在配对,要求等待
        - 11:显示已配对的信息
        - 12:重新请求系统配对
     - 退出：进入未配对状态

 - 用户点击【配对】
     - 配对成功后，收到“已配对成功，可以开始聊天”
     - 配对失败后，收到”配对失败，请再次尝试“
 - 用户点击【状态】
     - 返回其是否有配对对象
 - 用户点击【更换】
     - 取消其当前配对，结果类似点击【配对】的响应
 - 用户点击【退出】
     - 退出，回到普通模式

                    
####memcached的设计
维护用户的Session

Key：用户的ID（初定为微信提供的OPENID）  
Value：一个JSON组织的用户信息，包含状态，目标等等。

大致如此：
```
[
    '213112222': { // openid
        'state': 0/1, // 3种状态，0-申请配对中，1-已配对
        'target': '213113333', // 若状态为1时的聊天目标，状态0时为空
    }
]
```

####用户请求处理流程
 1. 检查msgType，event类别照旧处理，text进入第2步。
 2. 查看memcached，根据openid获取用户状态。分为两种情况，其一，无此key，说明为普通状态；其二，有此key，查看状态。
 3. 根据状态，进行相应的文本处理。
 
__普通状态__

类似event类别。

__调戏状态__

调用Simisimi API。

__互聊状态__

确定其是否有聊天对象。

有则直接将消息发给其对象。

没有则为其分配对象（类似摇一摇！！）。

 - 如果成功分配，则更新该用户以及被选择用户在memcached中的状态（target），然后告知这两位。
 - 分配失败（超过一定时间没找到同时要聊天的用户），告知用户，并提示用户更换状态。



__伪代码__

python
```
# 获取请求信息
msg_type = req_from_wechat['msg_type']
msg = req_from_wechat['msg']

mc = memcached.Client(...) # memcached句柄

if msg_type == u'event':
    # event类别，无需鉴别用户状态
    # do somthing
    pass
elif msg_type == u'text':
    # text类别，鉴别用户状态
    # 从memcached中获取用户状态
    cached_user_info = mc.get(user_id)
    
    if not cached_user_info:
        # 无记录，说明用户处于普通状态
        # 按普通状态处理文本
        pass
        
    else:
        state = cached_user_info['state']
        if state == 0:
            # 普通状态
            pass
        elif state == 1:
            # 调戏状态
            pass
        elif state == 2:
            # 互聊状态
            target = cached_user_info['target']
            if target and mc.get(target): # 有目标且目标仍处于互聊状态
                send_msg(target, msg) # 给目标发送消息
```


####类设计





#### 聊天接口
- OpenChat(OpenId)
 - 参数: 用户唯一ID
 - 返回值: 无
 - 功能: 为一个用户创建聊天跟踪状态
- ChangeStatus(OpenId,Status)
    - 参数: 用户唯一ID,状态码
    - 返回值: 无
    - 功能: 更改该用户的状态
- GetStatus(OpenId)
    - 参数: 用户唯一ID
    - 返回值: 状态码
   -  功能: 获取用户状态,不存在时返回0
- GetTarget(OpenId)
    - 参数: 用户唯一ID
    - 返回值: 该用户配对的用户ID
    - 功能: 返回与该用户配对的用户ID
- DelChat(OpenId)
    - 参数:用户唯一ID
    - 返回值: 无
    - 功能: 彻底删除用户的配对状态

- saveStorageToken(token,time)
    - 参数:令牌(512位以上),时间(int)
    - 返回值: 无
    - 功能: 将令牌及时间保存
- getStorageToken()
    - 参数: 无
    - 返回值: x['token'] x['date'],令牌及时间
    - 功能: 获取存储的信息,以数组形式返回
- postMsg(toUserId,msg)
    - 参数: 用户ID,消息
    - 返回值: 成功为True,失败为 False
    - 功能: 向指定用户推送出消息

#### 状态码
|Status|说明|
|:-----|:---|
|不存在(0)|未配对|
|1|正在配对|
|11|已配对|
|12|显示配对信息,再次请求时重新配对|