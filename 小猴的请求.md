#来自微信的验证（GET）
根据自身的token生成一个hash值返回给它即可

#来自用户的请求（POST）
来自用户的请求主要有两类（msgType）：

 - event
 - text
 
##event（事件模式）
通过点击下方的小按钮使用小猴，主要分为：

 - subscribe：新用户订阅
 - CLICK：下方工具条的点击，分为几种
     - 课表：
         - 更新课表
         - 明天课表
         - 今天课表
         - 下节课
     - 小工具：
         - 更新绑定信息
         - 教务信息
         - 空闲教室
         - 图书馆借书信息
         - 跑操次数
     - 关于





##text（文本模式）
通过打字（文本）使用小猴的功能。

目标计划分为三种状态，如下：

 - 普通：可以通过文字如”下节课“等使用小猴按钮的操作。
 - 互聊：为用户分配一个同样处于这样状态的用户，供他们之间聊天（匿名）。
     - 申请配对中（0）
     - 已配对（1）
 
###设计思路

使用 **memcached** 在服务器内存中缓存着用户的**状态信息**，每次根据状态的不同而对用户的请求做不同的处理。

**默认**的用户状态为普通，即使用户不进行状态选择的事件触发。用户切换状态需要手动点击按钮进行切换。

####设定的用户操作
 - 用户原本处于普通模式
 - 点击某个按钮，弹出一系列关于互聊的选择，如下：
     - 配对：进入互聊状态，并进行匹配
     - 状态：当前是否有匹配对象 // deleted
     - 更换：更换匹配对象
     - 退出：回到正常模式
 - 用户点击【配对】
     - 配对成功后，收到“已配对成功，可以开始聊天”
     - 配对失败后，收到”配对失败，请再次尝试“
 - 用户点击【状态】
     - 返回其是否有配对对象
 - 用户点击【更换】
     - 取消其当前配对，结果类似点击【配对】的响应
 - 用户点击【退出】
     - 退出，回到普通模式
                    
####memcached的设计
维护用户的Session

Key：用户的ID（初定为微信提供的OPENID）  
Value：一个JSON组织的用户信息，包含状态，目标等等。

大致如此：
```
[
    '213112222': { // openid
        'state': 0/1, // 3种状态，0-申请配对中，1-已配对
        'target': '213113333', // 若状态为1时的聊天目标，状态0时为空
    }
]
```

####用户请求处理流程
 1. 检查msgType，event类别照旧处理，text进入第2步。
 2. 查看memcached，根据openid获取用户状态。分为两种情况，其一，无此key，说明为普通状态；其二，有此key，查看状态。
 3. 根据状态，进行相应的文本处理。
 
__普通状态__

类似event类别。

__调戏状态__

调用Simisimi API。

__互聊状态__

确定其是否有聊天对象。

有则直接将消息发给其对象。

没有则为其分配对象（类似摇一摇！！）。

 - 如果成功分配，则更新该用户以及被选择用户在memcached中的状态（target），然后告知这两位。
 - 分配失败（超过一定时间没找到同时要聊天的用户），告知用户，并提示用户更换状态。



__伪代码__

python
```
# 获取请求信息
msg_type = req_from_wechat['msg_type']
msg = req_from_wechat['msg']

mc = memcached.Client(...) # memcached句柄

if msg_type == u'event':
    # event类别，无需鉴别用户状态
    # do somthing
    pass
elif msg_type == u'text':
    # text类别，鉴别用户状态
    # 从memcached中获取用户状态
    cached_user_info = mc.get(user_id)
    
    if not cached_user_info:
        # 无记录，说明用户处于普通状态
        # 按普通状态处理文本
        pass
        
    else:
        state = cached_user_info['state']
        if state == 0:
            # 普通状态
            pass
        elif state == 1:
            # 调戏状态
            pass
        elif state == 2:
            # 互聊状态
            target = cached_user_info['target']
            if target and mc.get(target): # 有目标且目标仍处于互聊状态
                send_msg(target, msg) # 给目标发送消息
```


####类设计
